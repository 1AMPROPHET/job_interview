# Vue

## 1. Vue 的理解

- 是一个用于创建用户界面的开源JavaScript 框架，也是一个创建单页应用的Web应用框架
- 是一套用于构建用户界面的渐进式MVVM框架。
- 包含
  - 声明式渲染
  - 组件化系统
  - 客户端路由
  - 大规模状态管理
  - 构建工具
  - 数据持久化
  - 跨平台支持等

## 2. Vue 中的双向绑定

### 什么是双向绑定

- 将model 绑定到view，当js更新model时，View会自动更新。

### 双向绑定的原理
  
- 双向绑定由三个重要的部分构成
  - 数据层：应用的数据和业务逻辑
  - 视图层：应用的展示效果，各类UI组件
  - 业务逻辑层：框架封装的核心，它负责将数据与视图关联起来

- ViewModel
  - 主要职责是
    - 数据变化后的更新视图
    - 视图变化后更新数据
  
  - 两个组成部分
    - 监听器（Observer）：对所有的数据的属性进行监听
    - 解析器（Compiler）：对每个元素几点的指令进行扫描跟解析，根据指令替换模板数据，以及绑定相应的更新函数

## 3. v-if & v-show

### 相同点

- 控制元素在页面是否显示

### 不同点

- 控制手段不同
- 编译过程不同
- 编译条件不同

### 控制手段

- v-show 隐藏是为元素添加 display：none，dom元素依旧还在
- v-if 显示隐藏是将dom元素整个添加或者删除

### 编译过程

- v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换

### 编译条件

- v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染
  - v-show 由false变为true的时候不会触发组件的生命周期
  
  - v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法

### 性能消耗

- v-if 有更高的切换消耗，v-show有更高的初始渲染消耗

- 如果需要非常频繁的切换，则使用v-show 较好
- 如果在运行时条件很少改变，则使用v-if 较好

## 4. Vue实例挂载的过程中发生了什么

- new Vue 的时候会调用_init方法

  - 定义 $set $get $delete $watch 等方法
  - 定义 $on、$off、$emit、$off 等事件
  - 定义 _update、$forceUpdate、$destroy生命周期

- 调用 $mount 进行页面的挂载

- 挂载的时候主要是通过mountComponent 方法
- 定义 updateComponent 更新函数
- 执行render 生成虚拟DOM
- _update 将虚拟DOM 生成真实DOM结构，并且渲染到页面中

## 5. Vue 生命周期

### 什么是生命周期

- Vue中实例从创建到销毁的过程就是生命周期

### 生命周期有哪些

| 生命周期      | 描述                             |
| ------------- | -------------------------------- |
| beforeCreate  | 组件实例被创建之初               |
| created       | 组件实例已经完全创建             |
| beforeMount   | 组件挂载之前                     |
| mounted       | 组件挂载到实例上去之后           |
| beforeUpdate  | 组件数据发生变化、更新之前       |
| updated       | 组件数据更新之后                 |
| beforeDestory | 组件实例销毁之前                 |
| destroyed     | 组件实例销毁之后                 |
| activated     | keep-alive 缓存的组件激活时      |
| deactivated   | keep-alive 缓存的组件停用时调用  |
| errorCaptured | 捕获一个来自孙组件的错误时被调用 |

### 具体分析

| 生命周期                | 分析                                                                                                                                                                                      |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| beforeCreate -> created | 初始化Vue实例，进行数据观测                                                                                                                                                               |
| created                 | 1. 完成数据观测，属性与方法的运算，watch、event事件回调的配置 2. 可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算 3. 此时vm.$el 并没有被创建 |
| beforeMount -> mounted  | 此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM                                                                                                                               |
| mounted                 | vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM                                                                                                       |
| beforeUpdate            | 1. 更新的数据必须是被渲染在模板上的（el、template、render之一） 2. 此时view层还未更新 3. 若在beforeUpdate中再次修改数据，不会再次触发更新方法                                             |
| updated                 | 1. 完成view层的更新 2. 若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）                                                                                             |
| beforeDestroy           | 实例被销毁前调用，此时实例属性与方法仍可访问                                                                                                                                              |
| destroyed               | 1. 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器 2. 并不能清除DOM，仅仅销毁实例                                                                                |

### 使用场景分析

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 |
| created       | 组件初始化完毕，各种数据可以使用，常用于异步数据获取         |
| beforeMount   | 未执行渲染、更新，dom未创建                                  |
| mounted       | 初始化结束，dom已创建，可用于获取访问数据和dom元素           |
| beforeUpdate  | 更新前，可用于获取更新前各种状态                             |
| updated       | 更新后，所有状态已是最新                                     |
| beforeDestroy | 销毁前，可用于一些定时器或订阅的取消                         |
| destroyed     | 组件已销毁，作用同上                                         |

### 数据请求在created和mouted的区别

- created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成mounted是在页面dom节点渲染完毕之后就立刻执行的触发时机上created是比mounted要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在create生命周期当中

## 6. v-if 与 v-for

- 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
- 避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环

## 7. SPA 首屏加载

### 什么是首屏加载

- 首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

- 首屏加载可以说是用户体验中最重要的环节

### 加载慢的原因

- 网络延迟大
- 资源文件体积过大
- 资源是否重复发送请求
- 加载脚本时，渲染内容阻塞

### 解决方案

- 减小入口文件体积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启Gzip压缩
- 使用SSR（服务端渲染）

### 为什么data 属性是一个函数

- 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染的情况
- 组件实例data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象

### Vue 添加新属性页面不刷新的解决

- Vue.set()
  - 使用了defineReactive方法，实现新增属性的响应式，关于defineReactive 方法，内部还是通过 defineProperty实现属性的拦截
- Object.assign()
  - 直接使用添加到对象的新属性并不会触发更新，应创建一个新的对象，合并元对象和混入对象的属性
- $forceUpdate
  - 强制刷新，不建议使用
- Vue3 是通过proxy实现数据响应式的，直接动态添加新的属性仍可以实现响应式

## 8. Vue 组件通信

### 组件通信概念

- 广义上，任何信息的交通都是通信，组件通信即指组件通过某种方法来传递信息以达到某个目的。

### 组件通信解决了什么

- 数据共享

### 组件通信的分类

- 父子组件之间的通信
- 兄弟组件之间的通信
- 祖孙组件之间的通信
- 非关系组件之间的通信

### 通信方案

- 通过props传递
- 通过 $emit 触发自定义事件
- 使用ref
- EventBus
- $parent 或 $root
- attrs 与 listeners
- Provide 与 Inject
- Vuex

## 9. $nextTick

### 什么是nextTick

- 我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新

### 原理

- 将回调函数放到callbacks等待执行
- 将执行函数梵高微任务或宏任务中
- 事件循环到了微任务或者宏任务，执行函数依次执行callback是中的回调

## 10. mixin

- 替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数
- 合并型策略是data，通过set方法进行合并和重新赋值
- 队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行
- 叠加型有component、directives、filters，通过原型链进行层层的叠加

## 11. Vue 中的 key

### 什么是key

- key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点

## 12. keep-alive

### 什么是keep-alive

- keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM

- keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

## 13. Vue中的修饰符

### 修饰符是什么

- 在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号
- 在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理
- Vue中的修饰符分为五类
  - 表单修饰符
  - 事件修饰符
  - 鼠标按键修饰符
  - 键值修饰符
  - v-bind修饰符

### 修饰符的作用

- 表单修饰符
  - lazy
    - 填完信息，光标离开标签的时候，才会将值赋予给value，也就是change事件之后再进行信息同步
  - trim
    - 自动过滤用户输入的首空格字符，不过滤中间空格
  - number
    - 自动转为数值类型

- 事件修饰符
  - stop
    - 阻止了事件冒泡
  - prevent
    - 阻止了事件的默认行为
  - self
    - 只当在 event.target 是当前元素自身时触发处理函数
  - once
    - 绑定了事件以后只能触发一次，第二次就不会触发
  - capture
    - 使事件触发从包含这个元素的顶层开始往下触发
  - passive
    - 在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符
  - native
    - 让组件变成像html内置标签那样监听根元素的原生事件

- 鼠标按钮修饰符
  - left
  - right
  - middle

- 键盘修饰符
- v-bind修饰符
  - async
    - 能对props进行一个双向绑定
  - props
    - 设置自定义标签属性，避免暴露数据，防止污染HTML结构
  - camel
    - 将命名法变为驼峰命名

## 14. 虚拟DOM

### 什么是虚拟DOM

- 实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上
- 在Javascript对象中，虚拟DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别
- 创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应

### 为什么需要虚拟DOM

- DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的
- 操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验

### 小结

- createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构

## 15. Vue 项目结构

### 为什么划分

- 使用vue构建项目，项目结构清晰会提高开发效率，熟悉项目的各种配置同样会让开发效率更高
- 在划分项目结构的时候，需要遵循一些基本的原则
  - 文件夹和文件夹内部文件的语义一致性
  - 单一入口/出口
  - 就近原则，紧耦合的文件应该放到一起，且应以相对路径引用
  - 公共的文件应该以绝对路径的方式从根目录引用
  - /src外的文件不应该被引入

## 16. Vue 权限管理

### 什么是权限管理

- 权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源
- 最终要实现的目标是：
  - 路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页
  - 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件
  - 最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截

### 怎么做

- 前端权限控制可以分为四个方面
  - 接口权限
  - 按钮权限
  - 菜单权限
  - 路由权限

## 17. Vue 如何解决跨域问题

### CORS

- 只要后端实现了CORS，就实现了跨域，通过添加中间件，设置Access-Control-Origin 请求头

### proxy

- 代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。

### Nginx反向代理

## 18. Vue3

### 简介

- 利用新的语言特性（es6）
- 解决架构问题

### 新变化

- 速度更快
  - 重写了虚拟DOM实现
  - 编译模板的优化
  - 更高效的组件初始化
  - undate性能提高了1.3~2倍
  - SSR 速度提高了2~3倍
- 体积减小
  - 通过webpack的tree shaking功能，仅打包需要的
- 更易维护
  - composition API
    - 可与现有的Options API 一起使用
    - 灵活的逻辑组合与复用
    - Vue3模块可以和其他框架搭配使用
    - 更好的TypeScript支持
- 更接近原生
  - 可自定义渲染API
- 更易使用
  - 响应式 Api 暴露出来

### 新增特性

- fragments
  - 支持多个根节点
- Teleport
  - Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术，就有点像哆啦A梦的“任意门”
- createRenderer
  - 构建自定义渲染器
- composition API
  - 组合式api，通过这种形式，能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理

### 非兼容变更

- Global API
  - 全局 Vue API 已经改为使用应用程序实例
  - 全局和内部 API 已经被重构为可 tree-shaking

- 模板指令
  - v-model用法已经更改
  - v-for 与 key用法修改
  - 在同一元素上 v-if 与 v-for 优先级已经修改
  - v-for 中的ref 不再注册 ref数组

### 移除 API

- keyCode 支持作为 v-on 的修饰符
- $on，$off 和 $once 实例方法
- 过滤filter
- 内联模板 attribute
- $destroy 实例方法。用户不应再手动管理单个 Vue 组件的生命周期。

## 19. Vue3 性能提升

### 编译阶段

- Vue3在编译阶段，做了进一步优化，主要有
  - diff 算法优化
    - 相比Vue2增加了静态标记，作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较
  - 静态提升
    - Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用，这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用
  - 事件监听缓存
    - 默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化
  - SSR优化
    - 当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染

### 源码体积

- 相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking，任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小

### 响应式系统

- vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式

- vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历

  - 可以监听动态属性的添加
  - 可以监听到数组的索引和数组length属性
  - 可以监听删除属性

## 20. proxy 代替 defineProperty

### defineProperty

- Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
- 通过defineProperty 两个属性，get及set
  - 属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值
  - 属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined

- 小结
  - 检测不到对象属性的添加和删除
  - 数组API方法无法监听，增加了set、delete API，并对数组API方法进行了一个重写
  - 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

### 什么是 proxy

- Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了

- 总结
  - 直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式的目的
  - 可以直接监听数组的变化

## 21. Composition API 与 Options API 有什么不同

- Vue2 项目的问题
  - 代码的可读性随着组件的变大而变差
  - 每一种代码服用的方式，都存在缺点
  - TypeScript支持有限

### Options API

- Options API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑
- 用组件的选项 (data、computed、methods、watch) 组织逻辑在大多数情况下都有效

- 然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解

### Composition API

- 在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）
- 逻辑复用
  - 在Vue2中，使用mixin混入来进行代码复用，单个mixin问题不大，但一个组件混入大量不同mixin 的时候，存在两个明显问题
    - 命名冲突
    - 数据来源不清晰
  - Vue3 中使用 Composition API 编写hook 函数

### 总结

- 在逻辑组织和逻辑服用方面，Composition API 是优于Options API
- 因为 Composition API几乎是函数，会有更好的类型推断
- Composition API 对 tree shaking 友好，代码也更容易压缩
- Composition API 中见不到this 的使用，减少了this只想不明的情况
- 如果是小型组件，可以继续使用Options API，也是十分友好地
