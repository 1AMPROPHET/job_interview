# computer network

## URI、URL、URN 分别是什么

- URL 代表资源的路径地址，而 URI 代表资源的名称

  - URI: Universal Resource Identifier 统一资源标志符

  - URL: Universal Resource Locator 统一资源定位符 URL 类似于住址，它告诉你一种寻找目标的方式(在这个例子中，是通过街道地址找到一个人)。要知道，上述定义同时也是一个 URI。
  - URN: Universal Resource Name 统一资源名称 我们可以把一个人的名字看作是 URN;因此可以用 URN 来唯一标识一个实体

## TCP 链接三次握手四次挥手

## 从输入网址到页面显示的过程

- 具体过程

  - DNS 解析
  - 发起 TCP 链接
  - 发送 HTTP 请求
  - 服务器处理请求并返回 HTTP 报文
  - 浏览器解析渲染页面
  - 连接结束

- DNS 解析
  - DNS 解析实际上就是寻找你所需要的资源的过程，是一个递归或迭代的过程，大致过程是
    - 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
    - 若没有命中缓存，则继续搜索操作系统的 DNS 缓存
    - 若仍然没有命中，则操作系统会将域名发送到本地域名服务器，本地域名服务器查询自己的缓存，查找成功则返回结果。（主机与本地域名服务器之间的查询方式是递归查询）
    - 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询。通过以下方式进行迭代查询
      - 首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名故武器的地址
      - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
      - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
    - 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
    - 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来
    - 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来
- 发起 TCP 链接
  - 三次握手、四次挥手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
  - 堆 TCP 链接进行处理，堆 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。报文分为三段：状态码、响应报头、响应报文
- 浏览器解析渲染页面
  - 解析 HTML 形成 DOM 树
  - 解析 CSS 形成 CSSOM 树
  - 合并为渲染树
  - 浏览器开始渲染并绘制页面

## GET POST

|                  | GET                                              | POST                                                    |
| ---------------- | ------------------------------------------------ | ------------------------------------------------------- |
| 后退按钮/刷新    | 无害                                             | 数据会被重新提交                                        |
| 书签             | 可收藏为书签                                     | 不可收藏                                                |
| 缓存             | 能缓存                                           | 不能缓存                                                |
| 编码类型         | application/x-www-form-unlencoded                | application/x-www-form-unlencoded 或 mutipart/form-data |
| 历史             | 参数保留在浏览器历史中                           | 参数不会保存在浏览器历史中                              |
| 对数据长度的限制 | url 长度受限（2048 字符 IE，8182 Chrome）        | 无限制                                                  |
| 数据类型限制     | 只允许 ASCII 字符                                | 没有限制                                                |
| 安全性           | 与 post 相比，get 安全性较差，敏感信息不要用 get | post 比 get 安全，因为参数不会保留在浏览器历史或日志中  |
| 可见性           | 数据在 url 中对所有人可见                        | 数据不显示再 url 中                                     |

- get 请求长度有限制
- post 比 get 安全，因为请求体不可见

## 常见 HTTP 请求方法

- GET：向服务器获取数据
- POST：将实体提交到指定资源，通常造成服务器资源的修改
- PUT：上传文件，修改数据
- DELETE：删除服务器上的对象
- HEAD：获取报文首部，与 GET 相比，不返回报文主体部分
- OPTIONS：询问支持的请求方法，用来跨域请求
- TRACE：追踪，请求-响应的传播路径
- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信

## HTTP 长连接、短链接、keep-alive 是干什么的

- 实质上是 TCP 的长连接、短链接
- 短链接
  - 浏览器和服务器每进行一次 HTTP 操作，就建立一个链接、任务结束会中断这个链接
- 长连接
  - HTTP1.1 规定了默认保持长连接，称为持久链接，数据传输完成后不断开，等待在同域名下继续用这个通道传输数据
- 长连接的好处

  - 同一个客户端可以使用这个长连接处理其他请求，避免重新连接和断开连接消耗的时间
  - 服务器可以主动利用这个链接主动推送消息到客户端

- HTTP 头部有了 Connection：keep-alive，代表客户希望这次请求是长连接的
- 优点
  - 较少的内存和 CPU 的使用
  - 允许请求和应答的 HTTP 管线化
  - 降低拥塞控制（TCP 连接减少了）
  - 减少了后续请求的延迟
  - 报告错误无需关闭 TCP 链接

## HTTP 对头阻塞

- 什么是队头阻塞
  - HTTP传输是基于 请求-应答 的模式进行的，报文必须是一发一收，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是队头阻塞

- 并发连接，相当于增加了任务队列
- 域名分片，多分几个域名，一个域名下可以分出很多二级域名。

## HTTP1.1 与 HTTP2

- 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

- 多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。

- 数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。

- 头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引 号，这样就能提高速度了。

- 服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

## HTTPS

- HTTPS 是在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密（在传输层）

- HTTP + 加密 + 认证 + 完整性保护 = HTTPS

- HTTPS 协议需要到 CA 申请证书或自制证书
- HTTP 的信息是明文传输；
- HTTPS 则是具有安全性的 ssl 加密
- HTTP 是直接与 TCP 进行数据传输；
- 而 HTTPS 运行在 SSL/TLS(安全传输层协议)之上，SSL/TLS 运行在 TCP 之上，用的端口也不一样，前者是 80（需要国内备案），后者是 443
- HTTP 的连接很简单，是无状态的；
- HTTPS 协议是由 SSL+HTTP 协议构建的，可进行加密传输、身份认证的网络协议，比 HTTP 协议安全

## HTTP1.1

- 持久连接
- 部分资源请求，返回码 206
- 缓存 Etag、if-Unmodified-Since 等
- 新增 host 字段，指定服务器域名
- 新增了请求方法：put、head、options 等

## HTTP2

- HTTP1.1 存在的问题
  - TCP连接数限制：对同一个域名，浏览器最多能同时创建6-8个TCP链接，为解决数量限制问题，出现了域名分片技术，将资源放在不同域名下（例如二级子域名），这样就可以针对不同域名创建连接并请求，但是每个TCP需经过DNS查询、三步握手、慢启动等，占用额外的CPU和内存，对服务器易造成网络拥挤，交通阻塞等。
  - 线头阻塞问题
  - header 内容多，而且每次header 变化不多
  - 为了尽可能减少请求数，需要做文件合并，雪碧图，资源内联等优化工作
  - 明文传输不安全

- HTTP2 的优势
  - 二进制分帧层，以二进制传输代替原本的明文传输，原本的报文信息被划分为更小的数据帧
  - 多路复用
    - 在一个TCP连接上，可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，根据这个标识来拼接每个流的所有帧组成一整块数据
    - 把HTTP1.1每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错的发送给对方
    - 流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题 所以 http2 对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接。
  - 服务器推送
    - 浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。 Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:

    - 客户端可以缓存推送的资源
    - 客户端可以拒收推送过来的资源
    - 推送资源可以由不同页面共享
    - 服务器可以按照优先级推送资源

  - header 压缩
    - 使用 HPACK 算法来压缩首部内容

  - 应用层的重置连接
    - 对于 HTTP/1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。

  - 请求优先级设置
    - HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题
  
  - 流量控制
    - 每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。

## 状态码

- 2XX

  - 200 OK
  - 204 No Content（未返回内容）
  - 206 Partial Content（包含 Content-Range）指定范围内的实体内容

- 3XX（Redirection 重定向状态码）

  - 301 永久重定向
  - 302 临时重定向
  - 303 表示请求的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源
  - 304 Not Modified 浏览器缓存相关，表示服务器允许访问资源，但是不满足条件，客户端存在缓存
  - 307 临时重定向，与 302 相同但不会将 post 请求变为 get
  - 308 永久重定向，但不允许将请求方法改post 为 get

- 4XX 客户端错误状态码

  - 401 Unauthorized
    - 401.1 登陆失败
    - 401.2 服务器配置导致登陆失败
    - 401.3 由于 ACL 对资源的限制而未获得授权
    - 401.4 筛选器授权失败
  - 403 Forbidden
  - 404 Not Found
  - 405 Method Not Allowed

- 5XX 服务器错误
  - 500 Internal server Error
  - 502 Bad Gateway 表明扮演网关或代理角色的服务器，从上游服务器中接受的信息是无效的
  - 503 Service Unavailable 表明服务器停机维护
  - 504 Gateway Timeout 超时

## encodeURIComponent

- 一般来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号，如果有汉字，就必须编码后使用
- encodeURI()是 JS 中真正用来对 URL 编码的函数
- encodeURIComponent 区别是，对于 URL 各部分进行个别编码，而不用对整个 URL 进行编码，对应解码函数为 decodeURIComponent

## Etag Last-Modified

- Etag 的出现，主要是解决 Last-Modified 无法解决的一些问题
  - 某些服务器不能精确到文件最后的修改时间，这样就无法通过最后修改时间来判断文件是否更新了
  - 某些文件的修改非常频繁，在秒以下的时间进行修改，Last-Modified 只能精确到秒
  - 一些文件最后修改时间变了，但是内容没变，我们不希望客户端认为这个文件修改了

## HTTP报文结构

- 起始行 + 头部 + 空行 + 实体

- 起始行
  - 对于请求报文来说，起始行类似于
    - GET/home HTTP/1.1 即方法 + 路径 + http版本
  - 对于响应报文来说，起始行一般为
    - HTTP/1.1 200 OK 即http版本、状态码、和原因三部分组成
  - 起始行中，每个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循ABNF语法规范

## 定长与不定长数据，HTTP怎么传输

- 定长包体
  - 对于定长包体而言，发送端在传输的时候一般会带上 Content-Length，来指定包体长度
- 不定长
  - Transfer-Encoding：chunked 表明分块传输数据，设置后会产生两个效果
    - Content-Length 字段会被忽略
    - 基于长连接持续推送动态内容

## 什么是CDN

- CDN全称是Content Delivery Network，即内容分发网络
- CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

- CDN的关键技术主要有内容存储和分发技术。

## 什么是 Nginx

- Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。

## 正向代理和反向代理

- 正向代理
  - 正向代理，"它代理的是客户端，代客户端发出请求"，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

  - 用途
    - 访问原来无法访问的资源，如Google
    - 可以做缓存，加速访问资源
    - 对客户端访问授权，上网进行认证
    - 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

- 反向代理
  - 客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。

  - 反向代理，"它代理的是服务端，代服务端接收请求"，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。

  - 用途
    - 保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网
    - 负载均衡，通过反向代理服务器来优化网站的负载

## TCP 与 UDP

- TCP
  - 面向连接的，可靠的流协议。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但是还是像没有任何间隔的数据流发送给接收端，TCP为提供可靠传输，实行“顺序控制”机制，此外还具备流控制、拥塞控制、提高网络利用率等众多功能

- UDP
  - 是不具备可靠性的数据报协议。虽然可以确保发送消息的大小，却不能保证消息一定会到达。

- 区别
  - 基于连接与无连接
  - 对系统资源的要求（TCP较多，UDP较少）
  - UDP程序结构较简单
  - 流模式与数据报模式
  - TCP保证数据正确性，UDP可能丢包
  - TCP保证数据顺序，UDP不保证

## 从存储位置看，浏览器缓存分为哪几种

- 从存储位置来看，浏览器缓存一共分为四种，并且各自有优先级，当依次查找缓存且都没有命中时，才会去请求网络
  - Service Worker
  - Memory Cache
  - Disk Cache
  - Push Cache