# Optimization

## 如何使用CSS提高页面性能

- 方法主要有
  - 内联首屏关键CSS
  - 异步加载CSS
  - 资源压缩
  - 合理使用选择器
  - 减少使用昂贵的属性
  - 不要使用@import

## SPA首屏加载

- 首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容
- 加载慢的原因
  - 网络延时问题
  - 资源文件体积是否过大
  - 资源是否重复发送请求去加载了
  - 加载脚本的时候，渲染内容堵塞了

- 解决方案
  - 减小入口文件积
  - 静态资源本地缓存
  - UI框架按需加载
  - 图片资源的压缩
  - 组件重复打包
  - 开启GZip压缩
  - 使用SSR

## script 标签中的 async 和 defer

- defer
  - 浏览器会异步下载该文件并且不会影响后续DOM的渲染
  - 如果有多个设置了defer属性的script标签存在，则会按照顺序执行所有的script，defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。
- async
  - async属性会使得script脚本异步的加载并在允许的情况下执行，而async的执行并不会按照script标签在页面中的顺序来执行，而是谁先加载完谁先执行。

## webpack 优化

- 压缩代码，丑化
- cdn加速
- tree shaking
- code split
- 公共第三方库

## 前端常规性能优化手段

- content 方面
  - 减少HTTP请求：合并文件、CSS精灵、inline Image
  - 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
  - 避免重定向：多余的中间访问
  - 使Ajax可缓存
  - 非必须组件延迟加载
  - 未来所需组件预加载
  - 减少DOM元素数量
  - 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
  - 减少iframe数量
  - 不要404

- Server 方面
  - 使用CDN
  - 添加Expires或者Cache-Control响应头
  - 对组件使用Gzip压缩
  - 配置ETag
  - Flush Buffer Early
  - Ajax使用GET进行请求
  - 避免空src的img标签

- Cookie 方面
  - 减小cookie 大下
  - 引入资源的域名不要包含cookie

- CSS 方面
  - 将样式表放到页面顶部
  - 不使用CSS表达式
  - 不使用IE的Filter

- JS方面
  - 将脚本放到页面底部
  - 将javascript和css从外部引入
  - 压缩javascript和css
  - 删除不需要的脚本
  - 减少DOM访问
  - 合理设计事件监听器

- 图片方面
  - 优化图片：根据实际颜色选择色深，压缩
  - 优化css精灵
  - 不要在HTML中拉伸图片
  - 保证favicon.ico小并可缓存

## 内存泄漏

- 内存泄漏的解释，程序中已经动态分配的堆内存由于某种原因未释放或无法释放
  - 根据js的垃圾回收机制，当内存中引用的次数为0的时候内存才会被回收
  - 全局执行上下文中的对象被标记为不再使用才会被释放
- 内存泄露的几种场景
  - 全局变量过多，通常是变量未定义或者乱引用全局变量
  - 闭包，未手动解决闭包遗留的内存引用
  - 事件监听未被移除
  - 缓存，建议所有缓存都设置好过期时间

## CSS 加载

- 结论
  - css加载不会阻塞DOM树的解析
  - css加载会阻塞DOM的渲染
  - css加载会阻塞后面js语句的执行

- 尽可能提高css加载速度
  - 使用CDN，CDN会根据网络状况，挑选最近的一个具有缓存内容的节点提供资源
  - 对css进行压缩
  - 合理使用缓存
  - 减少http请求数，将多个css文件合并

- 原理
  - HTML解析文件，生成DOM树，解析CSS生成CSSOM 树
  - 将DOM 树和CSSOM 树结合，生成Render tree
  - 根据render tree渲染绘制，将像素渲染到屏幕上

- 从过程可以看出
  - DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。
  - 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。
  - 由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

## window.requestAnimationFrame

- window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。
- 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。
- 还有两个优势
  - 页面最小化时，页面刷新任务也会停止，再次激活页面时，动画从上次停留的地方继续执行，有效节省了cpu开销
  - 函数节流：在高频事件resize、scoll中，为防止一个刷新间隔内发生多次函数调用，使用requestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，保证流畅性，也节省开销

## 列表 10000 个数据，怎么进行展示

- 思考 处理是否同步完成、数据是否按顺序完成
- 解决办法
  - 将数据分页，利用分页的原理，每次服务器端只需返回一定数目的数据，浏览器每次只对一部分进行加载
  - 使用懒加载方法，每次加载一部分数据，其余数据当需要时再去加载
  - 使用数据分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，然后再设置另一个定时器。

## 浏览器为什么要限制并发请求数

- 对操作系统端口资源考虑
  - PC总端口数为65536，一个TCP链接就占用一个端口，操作系统通常会对总端口一半开放对外请求，以防端口数量不被快速消耗殆尽
- 多并发导致频繁切换产生性能问题
  一个线程对应处理一个http请求，并发数量巨大的话会导致线程频繁切换
- 避免同一套客服端并发大量请求超过服务端并发阈值
- 客户端良知机制
  - 为了防止两个应用抢占资源时候导致强势一方无限制的获取资源导致弱势一方永远阻塞状态。

## React 中的性能优化

- 使用 shouldComponentUpdate 避免不必要的渲染，在有子组件情况下，为了避免子组件重复渲染，可以通过父组件来判断子组件是否需要PureRender
- 将 props 设置为数组或对象，每次嗲用 React 组件都会创建新组建，就算传入的数组或对象没有改变，他们的引用地址也会发生改变
- 将函数的绑定移动到构造函数内，可以避免每次都绑定事件
- 使用immutable 不可变数据
- 给子组件设置一个唯一的key，因为在diff 算法中，会使用key作为唯一标识优化渲染

## DNS 预解析

- DNS优化
  - 一般来说，一次DNS解析需要耗费20-120ms，所以为了优化DNS，我们可以考虑两个方向
    - 减少DNS请求次数
    - 缩短DNS解析时间 dns-prefetch
- 什么是dns-prefetch
  - DNS预获取是前端网络性能优化的一种措施，它根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，进而提高网站的访问速度
- 为什么要用 dns-prefetch
  - 每当浏览器从（第三方）服务器发送一次请求时，都要先通过DNS解析将该跨域域名解析为 IP地址，然后浏览器才能发出请求。如果某一时间内，有多个请求都发送给同一个服务器，那么DNS解析会多次并且重复触发。这样会导致整体的网页加载有延迟的情况。我们知道，虽然DNS解析占用不了多大带宽，但是它会产生很高的延迟，尤其是对于移动网络会更为明显。因此，为了减少DNS解析产生的延迟，我们可以通过dns-prefetch预解析技术有效地缩短DNS解析时间。
- dns-prefetch 背后原理
  - 当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。 在解析过程中，按照:
    - 浏览器缓存
    - 系统缓存
    - 路由器缓存
    - ISP(运营商)DNS缓存
    - 根域名服务器
    - 顶级域名服务器
    - 主域名服务器
  - 的顺序读取缓存，指导拿到IP地址。dns-prefetch 就是将解析后的IP缓存在系统中。这样，dns-prefetch 就有效的缩短了DNS解析时间，因为，在本地操作系统中做了DNS缓存，是的DNS在解析的过程中，提前在系统缓存中找到了对应IP，这样，后续的解析步骤就不用执行了，进而缩短了DNS解析时间
